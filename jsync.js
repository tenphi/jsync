// Generated by CoffeeScript 1.4.0
(function() {
  var clearObject, coffee, containsArray, evalCoffee, evalJS, extend, fs, getFilePath, getWatcher, handleObject, isCoffeeFile, isStored, js2coffee, jsync, listObjects, listWatchers, removeObject, sourin, storeObject, targ;

  fs = require('fs');

  coffee = require('coffee-script');

  js2coffee = require('js2coffee');

  targ = require('targ');

  sourin = require('sourin');

  jsync = function() {
    var context, file, filePath, handler, interval, obj, watcher, _ref;
    _ref = targ(arguments, {
      file: String,
      interval: Number,
      context: [Object, {}],
      handler: Function
    }), file = _ref.file, interval = _ref.interval, context = _ref.context, handler = _ref.handler;
    filePath = getFilePath(file);
    obj = jsync.read(filePath, context);
    handleObject(obj, handler);
    if (!obj) {
      throw 'error in file: ' + filePath;
    }
    watcher = function() {
      return jsync.read(filePath, watcher.context, function(err, newObj) {
        handleObject(newObj, handler);
        if (!newObj) {
          return;
        }
        clearObject(obj);
        return extend(obj, newObj);
      });
    };
    watcher.file = filePath;
    watcher.context = context;
    fs.watchFile(filePath, {
      persistent: true,
      interval: interval || jsync.interval
    }, watcher);
    storeObject(obj, watcher);
    return obj;
  };

  jsync.interval = 500;

  jsync.coffeeExts = ['coffee', 'cson'];

  jsync["eval"] = {};

  jsync.cancel = function(obj) {
    var watcher;
    watcher = getWatcher(obj);
    if (watcher) {
      fs.unwatchFile(watcher.file);
      removeObject(obj);
      return true;
    } else {
      return false;
    }
  };

  jsync.trigger = function(obj, context) {
    var watcher;
    watcher = getWatcher(obj);
    if (context) {
      watcher.context = context;
    }
    if (watcher) {
      watcher();
      return true;
    } else {
      return false;
    }
  };

  jsync.read = function() {
    var callback, context, data, file, filePath, handlePlain, _ref;
    _ref = targ(arguments, {
      file: String,
      context: [Object, {}],
      callback: Function
    }), file = _ref.file, context = _ref.context, callback = _ref.callback;
    if (!file) {
      throw 'file not set';
    }
    filePath = getFilePath(file);
    if (!fs.existsSync(filePath)) {
      throw 'file not found - ' + filePath;
    }
    handlePlain = function(data) {
      try {
        if (isCoffeeFile(filePath)) {
          return evalCoffee(data, context);
        } else {
          return evalJS(data, context);
        }
      } catch (e) {
        console.log(e);
      }
    };
    if (callback) {
      return fs.readFile(filePath, 'utf-8', function(err, data) {
        return callback(null, handlePlain(data));
      });
    } else {
      data = fs.readFileSync(filePath, 'utf-8');
      return handlePlain(data);
    }
  };

  jsync.save = function() {
    var callback, file, filePath, min, obj, src, watcher, _ref;
    _ref = targ(arguments, {
      obj: Object,
      file: String,
      min: Boolean,
      callback: Function
    }), obj = _ref.obj, file = _ref.file, min = _ref.min, callback = _ref.callback;
    if (!file) {
      watcher = getWatcher(obj);
      if (watcher) {
        file = watcher.file;
      }
    }
    if (!file) {
      throw 'file of object not found';
    }
    filePath = getFilePath(file);
    src = sourin(obj, min);
    if (isCoffeeFile(filePath)) {
      src = js2coffee.build(src);
    }
    if (callback) {
      fs.writeFile(filePath, src, 'utf-8', callback);
    } else {
      fs.writeFileSync(filePath, src, 'utf-8');
    }
    return jsync;
  };

  listObjects = [];

  listWatchers = [];

  storeObject = function(obj, watcher) {
    if (!isStored(obj)) {
      listObjects.push(obj);
      listWatchers.push(watcher);
    }
  };

  removeObject = function(obj) {
    var index;
    index = listObjects.indexOf(obj);
    if (index < 0) {
      return;
    }
    listObjects.splice(index, 1);
    listWatchers.splice(index, 1);
  };

  getWatcher = function(obj) {
    return listWatchers[listObjects.indexOf(obj)];
  };

  isStored = function(obj) {
    return !!~listObjects.indexOf(obj);
  };

  isCoffeeFile = function(file) {
    return ~jsync.coffeeExts.indexOf(file.split('.').pop());
  };

  evalJS = jsync["eval"].js = function(code, sandbox) {
    return (function() {
      return eval('(' + code + ')');
    }).call(sandbox || {});
  };

  evalCoffee = jsync["eval"].coffee = function(code, sandbox) {
    if (sandbox == null) {
      sandbox = {};
    }
    return (function() {
      code = '(\n' + code.split('\n').map(function(s) {
        return '	' + s;
      }).join('\n') + '\n)';
      return coffee["eval"](code, {
        sandbox: sandbox
      });
    }).call(sandbox);
  };

  handleObject = function(obj, handler) {
    if (handler) {
      if (!typeof obj === 'object') {
        return handler(true);
      } else {
        return handler(null, obj);
      }
    }
  };

  getFilePath = function(file) {
    if (file.charAt(0) === '/') {
      return file;
    } else {
      return __dirname + '/' + file;
    }
  };

  clearObject = function(obj) {
    var name, _results;
    if ('length' in obj && 'splice' in obj) {
      return obj.splice(0, obj.length);
    } else {
      _results = [];
      for (name in obj) {
        _results.push(delete obj[name]);
      }
      return _results;
    }
  };

  extend = function(obj, ext) {
    var name, _results;
    _results = [];
    for (name in ext) {
      _results.push(obj[name] = ext[name]);
    }
    return _results;
  };

  containsArray = function(text) {
    return text.trim()[0] === '[';
  };

  module.exports = jsync;

}).call(this);
